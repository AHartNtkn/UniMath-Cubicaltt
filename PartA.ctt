module PartA where

import Preamble

-- ============= Some standard constructions not using identity types (paths) ============= 
-- ============= Canonical functions from empty and to unit ============= 

fromempty (A : U) : empty -> A = split {}

tounit (A : U) (a : A) : unit = tt

-- ============= Functions from unit corresponding to terms =============

termfun (X : U) (x : X) : unit -> X = \(t : unit) -> x

-- ============= Identity functions and function composition =============

idfun (T : U) (t : T) : T = t

funcomp (X Y Z : U) (f : X -> Y) (g : Y -> Z) : X -> Z =
  \(x : X) -> g (f x)

funcomp_assoc (X Y Z W : U) (f : X -> Y) (g : Y -> Z) (h : Z -> W)
  : paths (X -> W) 
       (funcomp X Z W (funcomp X Y Z f g) h) 
       (funcomp X Y W f (funcomp Y Z W g h))
  = <_> \(x : X) -> h (g (f x))

-- ============= back and forth between functions of pairs and functions returning functions =============

curry (X : U) (Y : X -> U) (Z : U) (f : ((x:X) * Y x) -> Z) :
  (x : X) -> Y x -> Z = \(x : X) (yx : Y x) -> f (x, yx)

uncurry (X : U) (Y : X -> U) (Z : U) (f : (x:X) -> Y x -> Z) :
  ((x : X) * Y x) -> Z = \(p : (x : X) * Y x) -> f p.1 p.2

uncurry_curry (X : U) (Y : X -> U) (Z : U) (f: ((x:X) * Y x) -> Z) :
  paths (((x : X) * Y x) -> Z) (uncurry X Y Z (curry X Y Z f)) f = <_> f

curry_uncurry (X : U) (Y : X -> U) (Z : U) (f: (x:X) -> Y x -> Z) :
  paths ((x : X) -> Y x -> Z) (curry X Y Z (uncurry X Y Z f)) f = <_> f

-- ============= Iteration of an endomorphism =============

iteration (T : U) (f : T -> T) : nat -> T -> T = split
  zero  -> idfun T
  suc n -> funcomp T T T f (iteration T f n)

-- ============= Basic constructions related to the adjoint evaluation =============
-- function X -> ((X -> Y) -> Y)

adjev (X Y : U) (x : X) (f : X -> Y) : Y = f x

adjev2 (X Y : U) (phi : ((X -> Y) -> Y) -> Y) : X -> Y =
  \(x : X) -> phi (\(f : X -> Y) -> f x)

-- ============= Pairwise direct products =============
dirprod (X Y : U) : U = (x:X) * Y

dirprod_pr1 (X Y : U) (p : dirprod X Y) : X = p.1
dirprod_pr2 (X Y : U) (p : dirprod X Y) : Y = p.2

dirprodpair (X Y : U) (x : X) (y : Y) : dirprod X Y = (x, y)

dirprodadj (X Y Z : U) (f : dirprod X Y -> Z) : X -> Y -> Z =
  curry X (\(x : X) -> Y) Z f
-- \(x : X) (y : Y) -> f (dirprodpair X Y x y)

dirprodf (X Y X' Y' : U)
  (f : X -> Y) (f' : X' -> Y') (xx' : dirprod X X') : dirprod Y Y' =
  (f xx'.1, f' xx'.2)

ddualand (X Y P : U)
  (xp : (X -> P) -> P) (yp : (Y -> P) -> P) (X0 : dirprod X Y -> P) : P =
  xp (\(x : X) -> yp (\(y : Y) -> X0 (x, y)))

-- ============= Negation and double negation =============

neg (X : U) : U = X -> empty

neq (X : U) (x y : X) : U = neg (paths X x y)

negf (X Y : U) (f : X -> Y) : neg Y -> neg X =
  \(ny : neg Y)(x : X) -> ny (f x)

dneg (X : U) : U = neg (neg X)

dnegf (X Y : U) (f : X -> Y) : dneg X -> dneg Y =
  negf (neg Y) (neg X) (negf X Y f)

todneg (X : U) : X -> dneg X = adjev X empty

dnegnegtoneg (X : U) : dneg (neg X) -> neg X = adjev2 X empty

dneganddnegl1 (X Y : U) (dnx : dneg X) (dny : dneg Y) :
  neg (X -> neg Y) = \(X2 : X -> neg Y) -> dnegf X (neg Y) X2 dnx dny

dneganddnegimpldneg (X Y : U) (dnx : dneg X) (dny : dneg Y) :
  dneg (dirprod X Y) = ddualand X Y empty dnx dny

-- ============= Logical equivalence =============

logeq (X Y : U) : U = dirprod (X -> Y) (Y -> X)

isrefl_logeq (X : U) : logeq X X = (idfun X, idfun X)

issymm_logeq (X Y : U) (p : logeq X Y) : (logeq Y X) = (p.2, p.1)

logeqnegs (X Y : U) (l : logeq X Y ) : logeq (neg X) (neg Y) =
  (negf Y X l.2, negf X Y l.1)

logeq_both_true (X Y : U) : X -> Y -> (logeq X Y) =
  \(x : X)(y : Y) -> (\(x : X) -> y, \(y : Y) -> x)

logeq_both_false (X Y : U) : neg X -> neg Y -> (logeq X Y) =
  \(nx : neg X)(ny : neg Y) ->
    (\(x : X) -> fromempty Y (nx x)
    ,\(y : Y) -> fromempty X (ny y) )

logeq_trans (X Y Z : U) (lxy : logeq X Y) (lyz : logeq Y Z) : logeq X Z =
  (funcomp X Y Z lxy.1 lyz.1, funcomp Z Y X lyz.2 lxy.2)

-- ============= Operations on paths =============
-- ============= Composition of paths and inverse paths =============

pathscomp0 (X : U) (a b c : X) (e1 : paths X a b) (e2 : paths X b c) :
  paths X a c = <i> comp (<_> X) (e1 @ i) [(i=0) -> <_> a, (i=1) -> <j> e2 @ j]
-- This is an equivalent definition
-- transport (<i> paths X a (e2 @ i)) e1

pathscomp0rid (X : U) (a b : X) (e1 : paths X a b) :
  paths (paths X a b) (pathscomp0 X a b b e1 (<_> b)) e1 =
  <i j> fill (<_> X) (e1 @ j) [(j=0) -> <_> a,(j=1) -> <_> b] @ -i
-- This is an equivalent definition.
-- <j i> comp (<_> X) (e1 @ i) [(j = 1) -> <_> e1 @ i,(i=0) -> <_> a, (i=1) -> <_> b]

-- This is trivial in the original UniMath, but not in this setting. Wondering if there's a better way to prove this.
pathscomp0lid (X : U) (a b : X) (e1 : paths X a b)
  : paths (paths X a b) e1 (pathscomp0 X a a b (<_> a) e1)
  = paths_rect X a
      (\(x : X)(p : paths X a x) -> paths (paths X a x) p (pathscomp0 X a a x (<_> a) p))
      (<i> pathscomp0rid X a a (<_> a) @ -i) b e1

{- An alternative definition. Is there a shorter purely-cubical proof?
  <j i> comp (<_> X) (s @ i @ -j)
                     [(i=0) -> <k> a
                     ,(i=1) -> <k> c @ -j \/ k
                     ,(j=0) -> <k> e1 @ i
                     ,(j=1) -> <k> c @ i /\ k ]
  where
  c : paths X a b = pathscomp0 X a a b (<_> a) e1
  
  s : IdP (<k> paths X a (e1 @ k)) (<_> a) c
    = <j i> fill (<_> X) a [(i = 0) -> <_> a, (i=1) -> <k> e1 @ k] @ j
-}

-- Note: This should generally be avoided, unless the type of path cannot be inffered
pathsinv0 (X : U) (a b : X) (e : paths X a b) : paths X b a = <i> e @ -i    

-- Note, multiple instances of pathscomp0 should be avoided, as they are hard to manipulate.
--   This may not be an apropriate theorem for a cubical version of the library, and shouldn't be used.
path_assoc (X : U) (a b c d : X) (f : paths X a b) (g : paths X b c) (h : paths X c d)
  : paths (paths X a d) (pathscomp0 X a b d f (pathscomp0 X b c d g h))
                        (pathscomp0 X a c d (pathscomp0 X a b c f g) h)
  = paths_rect X c
      (\(x : X)(p : paths X c x) ->
        paths (paths X a x) (pathscomp0 X a b x f (pathscomp0 X b c x g p))
                            (pathscomp0 X a c x (pathscomp0 X a b c f g) p) )
      (pathscomp0 (paths X a c)
                  (pathscomp0 X a b c f (pathscomp0 X b c c g (<_> c)))
                  (pathscomp0 X a b c f g)
                  (pathscomp0 X a c c (pathscomp0 X a b c f g) (<_> c))
                  (<i> pathscomp0 X a b c f (pathscomp0rid X b c g @ i))
                  (<i> pathscomp0rid X a c (pathscomp0 X a b c f g) @ -i) )
      d h

-- Is there a better way to prove this?
pathsinv0l (X : U) (a b : X) (e : paths X a b)
  : paths (paths X a a) (pathscomp0 X a b a e (<i> e @ -i)) (<_> a)
  = paths_rect X a
      (\(x : X)(p : paths X a x) -> paths (paths X a a) (pathscomp0 X a x a p (<i> p @ -i)) (<_> a))
      (pathscomp0rid X a a (<_> a)) b e

-- Is there a better way to prove this?
pathsinv0r (X : U) (a b : X) (e : paths X a b)
  : paths (paths X b b) (pathscomp0 X b a b (<i> e @ -i) e) (<_> b)
  = paths_rect X a
      (\(x : X)(p : paths X a x) -> paths (paths X x x) (pathscomp0 X x a x (<i> p @ -i) p) (<_> x))
      (pathscomp0rid X a a (<_> a)) b e

pathsinv0inv0 (X : U) (x x' : X) (e : paths X x x')
  : paths (paths X x x') (<j> (pathsinv0 X x x' e) @ -j) e = <_> e

-- Is there a better way to prove this?
pathscomp_cancel_left (X:U) (x y z : X) (p: paths X x y) (r s : paths X y z)
  : paths (paths X x z) (pathscomp0 X x y z p r) (pathscomp0 X x y z p s) -> paths (paths X y z) r s
  = paths_rect X y
      (\(x : X)(p : paths X y x) ->
        paths (paths X x z) (pathscomp0 X x y z (<i> p @ -i) r) (pathscomp0 X x y z (<i> p @ -i) s) -> paths (paths X y z) r s )
      f x (<i> p @ -i)
  where
  f (prs : paths (paths X y z) (pathscomp0 X y y z (<_> y) r) (pathscomp0 X y y z (<_> y) s)) :
    paths (paths X y z) r s =
    transport (<i> paths (paths X y z) (pathscomp0lid X y z r @ -i) (pathscomp0lid X y z s @ -i)) prs

-- Is there a better way to prove this?
pathscomp_cancel_right (X:U) (x y z : X) (p q: paths X x y) (s : paths X y z)
  : paths (paths X x z) (pathscomp0 X x y z p s) (pathscomp0 X x y z q s) -> paths (paths X x y) p q
  = paths_rect X y
      (\(z : X)(s : paths X y z) ->
        paths (paths X x z) (pathscomp0 X x y z p s) (pathscomp0 X x y z q s) -> paths (paths X x y) p q)
      f z s
  where
  f (pqs : paths (paths X x y) (pathscomp0 X x y y p (<_> y)) (pathscomp0 X x y y q (<_> y)))
    : paths (paths X x y) p q
    = transport (<i> paths (paths X x y) (pathscomp0rid X x y p @ i) (pathscomp0rid X x y q @ i)) pqs

-- ============= Direct product of paths ============= 

pathsdirprod (X Y : U) (x1 x2 : X) (y1 y2 : Y) (ex : paths X x1 x2) (ey : paths Y y1 y2) 
  : paths ((_ : X) * Y) (x1, y1) (x2, y2) 
  = <i> (ex @ i, ey @ i)

-- ============= The function maponpaths between paths types defined by a =============
-- function between ambient types and its behavior relative to @ and !

-- Note: unless the type of the path cannot be inffered, this should generally be avoided
maponpaths (T1 T2 : U) (f : T1 -> T2) (t1 t2 : T1) (e : paths T1 t1 t2)
  : paths T2 (f t1) (f t2) = <i> f (e @ i)

-- Is there a better way to prove this?
maponpathscomp0 (X Y : U) (x1 x2 x3 : X) (f : X -> Y) (e1 : paths X x1 x2) (e2 : paths X x2 x3)
  : paths (paths Y (f x1) (f x3))
      (<i> f (pathscomp0 X x1 x2 x3 e1 e2 @ i))
      (pathscomp0 Y (f x1) (f x2) (f x3) (<i> f (e1 @ i)) (<i> f (e2 @ i)))
  = <j i> comp (<_> Y) (f (e1 @ i))
                       [(i=0) -> <k> f x1
                       ,(i=1) -> <k> f (e2 @ k)
                       ,(j=0) -> <k> f (fill (<_> X) (e1 @ i) [(i=0) -> <_> x1, (i=1) -> e2] @ k)
                       ,(j=1) -> <k> fill (<_> Y) (f (e1 @ i)) [(i=0) -> <_> f x1, (i=1) -> <k> f (e2 @ k)] @ k ]

maponpathsinv0 (X Y : U) (f : X -> Y) (x1 x2 : X) (e : paths X x1 x2)
               : paths (paths Y (f x2) (f x1))
                       (maponpaths X Y f x2 x1 (<i> e @ -i))
                       (<i> maponpaths X Y f x1 x2 e @ -i)
               = <_ i> f (e @ -i)

-- ============= maponpaths for the identity functions and compositions of functions ============= 

maponpathsidfun (X : U) (x x' : X) (e : paths X x x')
  : paths (paths X x x') (<i> (idfun X) (e @ i)) e
  = <_> e

maponpathscomp (X Y Z : U) (x x' : X) (f : X -> Y) (g : Y -> Z) (e : paths X x x')
  : paths (paths Z (g (f x)) (g (f x'))) (<i> g (maponpaths X Y f x x' e @ i))
                                         (<i> (funcomp X Y Z f g) (e @ i))
  = <_ i> g (maponpaths X Y f x x' e @ i)

-- naturality of maponpaths

maponpaths_naturality (X Y : U) (f:X->Y) (x x' x'':X) (p:paths X x x') (q: paths X x' x'')
           (p':paths Y (f x) (f x')) (q':paths Y (f x') (f x''))
           (r:paths (paths Y (f x) (f x'))   (<i> f (p @ i)) p')
           (s:paths (paths Y (f x') (f x'')) (<i> f (q @ i)) q')
  : paths (paths Y (f x) (f x'')) (<i> f (pathscomp0 X x x' x'' p q @ i))
                                  (pathscomp0 Y (f x) (f x') (f x'') p' q')
  = transport (<i> paths (paths Y (f x) (f x''))
                         (<i> f (pathscomp0 X x x' x'' p q @ i))
                         (pathscomp0 Y (f x) (f x') (f x'') (r @ i) (s @ i))  )
              (maponpathscomp0 X Y x x' x'' f p q)

maponpaths_naturality' (X Y:U) (f:X->Y) (x x' x'':X) (p:paths X x' x) (q:paths X x' x'')
           (p':paths Y (f x') (f x)) (q':paths Y (f x') (f x''))
           (r:paths (paths Y (f x') (f x))   (<i> f (p @ i)) p')
           (s:paths (paths Y (f x') (f x'')) (<i> f (q @ i)) q')
  : paths (paths Y (f x) (f x'')) (<j> f (pathscomp0 X x x' x'' (<i> p @ -i) q @ j))
                                  (pathscomp0 Y (f x) (f x') (f x'') (<i> p' @ -i) q')
  = maponpaths_naturality X Y f x x' x'' (<i> p @ -i) q (<i> p' @ -i) q' (<i j> r @ i @ -j) s

{-
The following three statements show that maponpaths defined by a function f which is homotopic to the identity is "surjective". It is later used to show that the maponpaths defined by a function which is a weak equivalence is itself a weak equivalence.
-}

maponpathshomidinv (X : U) (f : X -> X)
  (h : (x : X) -> paths X (f x) x) (x x' : X) (e : paths X (f x) (f x')) : paths X x x' =
  <i> comp (<_> X) (e @ i) [(i=0) -> h x, (i=1) -> h x']
-- This is an alternative proof, closer to the one present in the original UniMath.
-- pathscomp0 X x (f x) x' (<i> h x @ -i) (pathscomp0 X (f x) (f x') x' e (h x'))
-- Note that the definition used here is far easier to reason about, as can be seen in maponpathshomid2.
--      that proof would fail, and would likely be far more complicated if the original definition were to be used.

maponpathshomid1 (X : U) (f : X -> X) (h : (x : X) -> paths X x (f x)) (x x' : X) (e : paths X x x')
  : paths (paths X (f x) (f x'))
          (<i> f (e @ i))
          (<i> comp (<_> X) (e @ i) [(i=0) -> h x, (i=1) -> h x'])
  = <j i> comp (<_> X) (e @ i) [(i = 0) -> h x, (i = 1) -> h x', (j = 0) -> h (e @ i)]

-- Is there a better way to prove this?
maponpathshomid2 (X : U) (f : X -> X) (h: (x : X) -> paths X (f x) x) (x x' : X) (e: paths X (f x) (f x'))
  : paths (paths X (f x) (f x')) (<i> f (maponpathshomidinv X f h x x' e @ i)) e
  = <j i> comp (<_> X) (maponpathshomidinv X f h x x' e @ i)
                       [(i=0) -> <k> h x @ -k
                       ,(i=1) -> <k> h x' @ -k
                       ,(j=0) -> <k> h (maponpathshomidinv X f h x x' e @ i) @ -k
                       ,(j=1) -> <k> fill (<_> X) (e @ i) [(i=0) -> h x, (i=1) -> h x'] @ -k ]

-- Here we consider the behavior of maponpaths in the case of a projection p with a section s.

pathssec1 (X Y : U) (s : X -> Y) (p : Y -> X) (eps : (x : X) -> paths X (p (s x)) x)
  (x : X) (y : Y) (e : paths Y (s x) y) : paths X x (p y)
  = <i> comp (<_> X) (p (e @ i)) [(i=0) -> eps x, (i=1) -> <_> p y]

pathssec2 (X Y : U) (s : X -> Y) (p : Y -> X) (eps : (x : X) -> paths X (p (s x)) x)
  (x x' : X) (e : paths Y (s x) (s x')) : paths X x x'
  = <i> comp (<_> X) (p (e @ i)) [(i=0) -> eps x, (i=1) -> eps x']

pathssec2id (X Y : U) (s : X -> Y) (p : Y -> X) (eps : (x : X) -> paths X (p (s x)) x) (x : X)
  : paths (paths X x x) (pathssec2 X Y s p eps x x (<_> (s x))) (<_> x)
  = <j i> comp (<_> X) (p (s x)) [(i = 0) -> eps x, (i = 1) -> eps x, (j = 1) -> eps x] 

pathssec3 (X Y : U) (s : X -> Y) (p : Y -> X) (eps : (x : X) -> paths X (p (s x)) x)
  (x x' : X) (e : paths X x x') : paths (paths X x x') (pathssec2 X Y s p eps x x' (<i> s (e @ i))) e
  = <j i> comp (<_> X) (p (s (e @ i))) [(i = 0) -> eps x, (i = 1) -> eps x', (j = 1) -> eps (e @ i)]

map_on_two_paths (X Y Z : U) (f:X -> Y -> Z) (x x' : X) (y y' : Y) 
  (px : paths X x x') (py : paths Y y y') : paths Z (f x y) (f x' y') = <i> f (px @ i) (py @ i)
  
-- ============= Fibrations and paths =============

tppr (T : U) (P : T -> U) (x : total2 T P) : paths (total2 T P) x (x.1, x.2) = <_> x

constr1 (X : U) (P : X -> U) (x x' : X) (e : paths X x x')
  : (f : P x -> P x') *
    (ee : (p : P x) -> paths (total2 X P) (x, p) (x', f p)) *
    (pp : P x) -> paths (paths X x x') (<i> (ee pp @ i).1) e
  = (\(p : P x) -> transport (<i> P (e @ i)) p
    ,\(p : P x) -> <i> (e @ i, fill (<j> P (e @ j)) p [] @ i)
    ,\(p : P x) -> <_> e)
{- This is the way it's done in the original library, but I think my way is better.
    paths_rect X x
      (\(x':X)(e:paths X x x') -> (f:P x->P x') * (ee : (p : P x) -> paths (total2 X P) (x, p) (x', f p)) *
                                  (pp : P x) -> paths (paths X x x') (<i> (ee pp @ i).1) e )
      (idfun (P x), \(p:P x) -> <_> (x, p), \(p:P x) -> <_ _> x) x' e
-}

-- Note: Generally, this should be avoided in favor of the built-in notation.
transportf (X : U) (P : X -> U) (x x' : X) (e : paths X x x') (px : P x) : P x' = transport (<i> P (e @ i)) px
-- This definition is closer to what's presented in the original library
-- (constr1 X P x x' e).1

-- Note: Generally, this should be avoided in favor of the built-in notation.
transportb (X : U) (P : X -> U) (x x' : X) (e : paths X x x') (px : P x') : P x = transport (<i> P (e @ -i)) px
-- This definition is closer to what's presented in the original library
-- transportf X P x' x (pathsinv0 X x x' e)

dpath_transportf (X : U) (P:X->U) (x:X) (p:P x) : paths (P x) p (transport (<i> P x) p) = fill (<_> P x) p []

-- Note: This theorem is trivial both in statement and in proof in CubicalTT, even if we
--       strictly follow how it's done in the original UniMath.
functtransportf (X Y : U) (f : X -> Y) (P : Y -> U) (x x' : X) (e : paths X x x') (p : P (f x))
  : paths (P (f x')) (transport (<i> P (f (e @ i))) p) (transport (<i> P (f (e @ i))) p)
  = <_> transport (<i> P (f (e @ i))) p

-- Note: This theorem is trivial both in statement and in proof in CubicalTT, even if we
--       strictly follow how it's done in the original UniMath.
functtransportb (X Y : U) (f : X -> Y) (P : Y -> U) (x x' : X) (e : paths X x' x) (p : P (f x))
  : paths (P (f x')) (transport (<i> P (f (e @ -i))) p) (transport (<i> P (f (e @ -i))) p)
  = <_> transport (<i> P (f (e @ -i))) p

-- Is there a better way to prove this?
transport_f_b (X : U) (P : X -> U) (x y z : X) (e : paths X y x) (e' : paths X y z) (p : P x)
  : paths (P z) (transport (<i> P (e' @ i)) (transport (<i> P (e @ -i)) p))
                (transport (<i> P (pathscomp0 X x y z (<j> e @ -j) e' @ i)) p)
  = paths_rect X y
      (\(z : X)(e' : paths X y z) ->
        paths (P z) (transport (<i> P (e' @ i)) (transport (<i> P (e @ -i)) p))
                    (transport (<i> P (pathscomp0 X x y z (<j> e @ -j) e' @ i)) p)  )
      (<i> comp (<j> P (fill (<_> X) (e @ -j /\ i) [(j=0) -> <_> e @ i,(j=1) -> <_> y] @ i))
               (fill (<j> P (e @ -j)) p [] @ -i) [])
      z e'

transport_b_f (X : U) (P : X -> U) (x y z : X) (e : paths X x y) (e' : paths X z y) (p : P x)
  : paths (P z)
          (transport (<i> P (e' @ -i)) (transport (<i> P (e @ i)) p))
          (transport (<j> P (pathscomp0 X x y z e (<i> e' @ -i) @ j)) p)
  = transport_f_b X P x y z (<i> e @ -i) (<i> e' @ -i) p

transport_f_f (X : U) (P : X -> U) (x y z : X) (e : paths X x y) (e' : paths X y z) (p : P x)
  : paths (P z) (transport (<i> P (e' @ i)) (transport (<i> P (e @ i)) p)) (transport (<i> P (pathscomp0 X x y z e e' @ i)) p)
  = transport_f_b X P x y z (<i> e @ -i) e' p

-- Is there a better way to do this?
transport_b_b (X : U) (P : X -> U) (x y z : X) (e : paths X x y) (e' : paths X y z) (p : P z)
  : paths (P x) (transport (<i> P (e @ -i)) (transport (<i> P (e' @ -i)) p))
                (transport (<i> P (pathscomp0 X x y z e e' @ -i)) p)
  = paths_rect X y
      (\(x : X)(e : paths X y x) ->
         paths (P x) (transport (<i> P (e @ i)) (transport (<i> P (e' @ -i)) p))
                     (transport (<j> P (pathscomp0 X x y z (<i> e @ -i) e' @ -j)) p)  )
      d x (<i> e @ -i)
  where
  d2 : paths (P z) (transport (<_> P z) (transport (<_> P z) p))
                   (transport (<i> P (pathscomp0 X z z z (<_> z) (<_> z) @ i)) p)
     = <i> comp (<j> P (pathscomp0rid X z z (<_> z) @ -i @ j)) (fill (<_> P z) p [] @ -i) []
  
  d : paths (P y) (transport (<_> P y) (transport (<i> P (e' @ -i)) p))
                  (transport (<i> P (pathscomp0 X y y z (<_> y) e' @ -i)) p)
    = paths_rect X z
        (\(y : X)(e' : paths X z y) ->
           paths (P y) (transport (<_> P y) (transport (<i> P (e' @ i)) p))
                       (transport (<j> P (pathscomp0 X y y z (<_> y) (<i> e' @ -i) @ -j)) p) )
        d2 y (<i> e' @ -i)

-- Is there a better way to prove this?
transport_map (X : U) (P Q : X -> U) (f : (x : X) -> P x -> Q x) (x y : X) (e : paths X x y) (p : P x)
  : paths (Q y) (transport (<i> Q (e @ i)) (f x p)) (f y (transport (<i> P (e @ i)) p))
  = paths_rect X x
      (\(y : X)(e : paths X x y) ->
         paths (Q y) (transportf X Q x y e (f x p)) (f y (transportf X P x y e p))  )
      (<i> comp (<_> Q x) (fill (<_> Q x) (f x p) [] @ -i)
                          [(i=0) -> <_> comp (<_> Q x) (f x p) []
                          ,(i=1) -> <j> f x (fill (<_> P x) p [] @ j) ] )
      y e

transport_section (X : U) (P : X -> U) (f: (x : X) -> P x) (x y : X) (e : paths X x y)
  : paths (P y) (transportf X P x y e (f x)) (f y)
  = transport_map X (\(x : X) -> unit) P (\(x : X)(px : unit) -> f x) x y e tt

-- A series of lemmas about paths and sigma types. Adapted from the HoTT library http://github.com/HoTT/HoTT

-- Generally avoid using this.
base_paths (A : U) (B : A -> U) (a b : total2 A B) (p : paths (total2 A B) a b)
  : paths A a.1 b.1
  = <i> (p @ i).1

-- This is the version of the theorem used in the original library, don't use it.
total2_paths_OLD (A : U) (B : A -> U) (s s' : (x : A) * B x)
    (p : paths A s.1 s'.1)
    (q : paths (B s'.1) (transportf A B s.1 s'.1 p s.2) s'.2)
  : paths ((x : A) * B x) s s'
  = <i> (p @ i, d @ i)
  where
  d : IdP (<i> B (p @ i)) s.2 s'.2
    = <i> comp (<_> B (p @ i))
               (fill (<j> B (p @ j)) s.2 [] @ i)
               [(i = 0) -> <_> s.2, (i = 1) -> q]

-- This is a theorem only here since it's present in the original library, don't use it.
total2_paths_b (A : U) (B : A -> U) (s s' : (x : A) * B x)
    (p : paths A s.1 s'.1)
    (q : paths (B s.1) s.2 (transportb A B s.1 s'.1 p s'.2))
  : paths ((x : A) * B x) s s'
  = <i> (p @ i, d @ -i)
  where
  d : IdP (<i> B (p @ -i)) s'.2 s.2
    = <i> comp (<_> B (p @ -i))
               (fill (<j> B (p @ -j)) s'.2 [] @ i)
               [(i = 0) -> <_> s'.2, (i = 1) -> <i> q @ -i]

-- Generally avoid using this, except when something fails to infer.
total2_paths (A : U) (B : A -> U) (s s' : (x : A) * B x)
    (p : paths A s.1 s'.1)
    (q : IdP (<i> B (p @ i)) s.2 s'.2)
  : paths ((x : A) * B x) s s'
  = <i> (p @ i, q @ i)

total2_paths2 (A : U) (B : A -> U) (a1 : A) (b1 : B a1) (a2 : A) (b2 : B a2)
    (p : paths A a1 a2)
    (q : IdP (<i> B (p @ i)) b1 b2)
  : paths ((x : A) * B x) (a1, b1) (a2, b2)
  = <i> (p @ i, q @ i)

pair_path_in2 (X : U) (P:X -> U) (x:X) (p q:P x) (e:paths (P x) p q)
  : paths ((x : X) * P x) (x, p) (x, q)
  = <i> (x, e @ i)

-- Generally avoid using this
fiber_paths (A : U) (B : A -> U) (u v : (x : A) * B x) (p : paths ((x : A) * B x) u v)
  : IdP (<i> B (p @ i).1) u.2 v.2
  = <i> (p @ i).2

total2_fiber_paths (A : U) (B : A -> U) (x y : (x : A) * B x) (p : paths (total2 A B) x y)
  : IdP (<_> paths (total2 A B) x y) (<i> ((p @ i).1, (p @ i).2)) p
  = <_> p

base_total2_paths (A : U) (B : A -> U) (x y : (x : A) * B x)
    (p : paths A x.1 y.1)
    (q : IdP (<i> B (p @ i)) x.2 y.2)
  : paths (paths A x.1 y.1) (<i> (total2_paths A B x y p q @ i).1) p
  = <_> p

-- Note that, due to theorems like base_total2_paths being trivial here,
--   much of the structure of this theorem collapses.
transportf_fiber_total2_paths (A : U) (B : A -> U) (x y : (x : A) * B x)
    (p : paths A x.1 y.1)
    (q : IdP (<i> B (p @ i)) x.2 y.2)
  : paths (IdP (<i> B (p @ i)) x.2 y.2)
          (transport (<i> IdP (<j> B (p @ j)) x.2 y.2)
                     (<i> (total2_paths A B x y p q @ i).2) )
          q
  = <j i> fill (<_> B (p @ i)) (q @ i) [(i = 0) -> <_> x.2, (i = 1) -> <_> y.2 ] @ -j

-- Lemmas about transport Adapted from the HoTT library and the HoTT book

transportD (A : U) (B : A -> U) (C : (a : A) -> B a -> U)
    (x1 x2 : A) (p : paths A x1 x2) (y : B x1) (z : C x1 y)
  : C x2 (transport (<i> B (p @ i)) y)
  = transport (<i> C (p @ i) (fill (<j> B (p @ j)) y [] @ i)) z

transportf_total2 (A : U) (B : A -> U) (C : (a : A) -> B a -> U)
  (x1 x2 : A) (p : paths A x1 x2) (yz : (y : B x1) * C x1 y)
  : paths ((y : B x2) * C x2 y)
          (transport (<i> (y : B (p @ i)) * C (p @ i) y) yz)
          (transport (<i> B (p @ i)) yz.1
          ,transportD A B C x1 x2 p yz.1 yz.2)
  = <_> transport (<i> (y : B (p @ i)) * C (p @ i) y) yz

transportf_dirprod (A : U) (B B' : A -> U) (x x' : (a : A) * dirprod (B a) (B' a)) (p : paths A x.1 x'.1)
  : paths ((_ : B x'.1) * B' x'.1)
          (transport (<i>  (_ : B (p @ i)) * B' (p @ i)) x.2)
          (transport (<i> B (p @ i)) x.2.1
          ,transport (<i> B' (p @ i)) x.2.2)
  = <_> transport (<i>  (_ : B (p @ i)) * B' (p @ i)) x.2        

transportf_id1 (A : U) (a x1 x2 : A) (p : paths A x1 x2) (q : paths A a x1)
  : paths (paths A a x2)
          (transport (<i> paths A a (p @ i)) q)
          (pathscomp0 A a x1 x2 q p)
  = <_> pathscomp0 A a x1 x2 q p

-- Is there a better way to prove this?
transportf_id2 (A : U) (a x1 x2 : A) (p : paths A x1 x2) (q : paths A x1 a)
  : paths (paths A x2 a)
          (transport (<i> paths A (p @ i) a) q)
          (pathscomp0 A x2 x1 a (<i> p @ -i) q)
  = <i> comp (<_> paths A x2 a)
             (<j> comp (<_> A) x1 [ (j = 0) -> p, (j = 1) -> q ])
             [(i = 0) -> <k i> comp (<_> A) (q @ i /\ k) [(i = 0) -> p, (i = 1) -> <l> q @ l \/ k ]
             ,(i = 1) -> <k i> comp (<_> A) (p @ -i /\ k) [(i = 0) -> <l> p @ l \/ k, (i = 1) -> q ] ]

transportf_id3 (A : U) (x1 x2 : A) (p : paths A x1 x2) (q : paths A x1 x1)
  : paths (paths A x2 x2)
          (transport (<i> paths A (p @ i) (p @ i)) q)
          (<i> comp (<_> A) (q @ i) [(i=0) -> p, (i=1) -> p])
  = <_> transport (<i> paths A (p @ i) (p @ i)) q

-- ============= First homotopy notions ============= 
-- Homotopy between functions

-- It *might* be a good idea to avoid using homot in favor of using just its definition
homot (X : U) (P : X -> U) (f g : (x : X) -> P x) : U = (x : X) -> paths (P x) (f x) (g x)

homotcomp (X Y : U) (f f' f'' : X -> Y)
  (h : homot X (\(_:X)->Y) f f') (h' : homot X (\(_:X)->Y) f' f'')
  : homot X (\(_:X)->Y) f f''
  = \(x : X) -> pathscomp0 Y (f x) (f' x) (f'' x) (h x) (h' x)

invhomot (X Y : U) (f f' : X -> Y) (h : homot X (\(_:X)->Y) f f' )
  : homot X (\(_:X)->Y) f' f
  = \(x : X) -> <i> h x @ -i

funhomot (X Y Z : U) (f : X -> Y) (g g' : Y -> Z) (h : homot Y (\(_:Y)->Z) g g' )
  : homot X (\(_:X)->Z) (funcomp X Y Z f g) (funcomp X Y Z f g') 
  = \(x : X) -> h (f x)

homotfun (X Y Z : U) (f f' : X -> Y) (h : homot X (\(_:X)->Y) f f') (g : Y -> Z)
  : homot X (\(_:X)->Z) (funcomp X Y Z f g) (funcomp X Y Z f' g)
  = \(x : X) -> <i> g (h x @ i)

-- Contractibility, homotopy fibers etc.
-- Contractible types.

iscontr (T:U) : U = (cntr:T) * (t:T) -> paths T t cntr

iscontrpair (T : U)
  : (x : T) -> ((t : T) -> paths T t x) -> iscontr T
  = tpair T (\(x : T) -> (t : T) -> paths T t x)

iscontrpr1 (T : U) (k : iscontr T) : T = k.1

iscontrretract (X Y : U) (p : X -> Y) (s : Y -> X)
  (eps : (y : Y) -> paths Y (p (s y)) y) (is : iscontr X) : iscontr Y
  = (p is.1, \(t : Y) -> <i> comp (<_> Y) (p (is.2 (s t) @ i)) [(i=0) -> eps t, (i=1) -> <_> p is.1])

proofirrelevancecontr (X : U) (is : iscontr X) (x x' : X) : paths X x x'
  = <i> comp (<_> X) is.1 [(i=0) -> <i> is.2 x @ -i, (i=1) -> <i> is.2 x' @ -i]
