module PartA where

import Preamble

-- ============= Some standard constructions not using identity types (paths) ============= 
-- ============= Canonical functions from empty and to unit ============= 

fromempty (A : U) : empty -> A = split {}

tounit (A : U) (a : A) : unit = tt

-- ============= Functions from unit corresponding to terms =============

termfun (X : U) (x : X) : unit -> X = \(t : unit) -> x

-- ============= Identity functions and function composition =============

idfun (T : U) (t : T) : T = t

funcomp (X Y Z : U) (f : X -> Y) (g : Y -> Z) : X -> Z =
  \(x : X) -> g (f x)

funcomp_assoc (X Y Z W : U) (f : X -> Y) (g : Y -> Z) (h : Z -> W)
  : paths (X -> W) 
       (funcomp X Z W (funcomp X Y Z f g) h) 
       (funcomp X Y W f (funcomp Y Z W g h))
  = <_> \(x : X) -> h (g (f x))

-- ============= back and forth between functions of pairs and functions returning functions =============

curry (X : U) (Y : X -> U) (Z : U) (f : ((x:X) * Y x) -> Z) :
  (x : X) -> Y x -> Z = \(x : X) (yx : Y x) -> f (x, yx)

uncurry (X : U) (Y : X -> U) (Z : U) (f : (x:X) -> Y x -> Z) :
  ((x : X) * Y x) -> Z = \(p : (x : X) * Y x) -> f p.1 p.2

uncurry_curry (X : U) (Y : X -> U) (Z : U) (f: ((x:X) * Y x) -> Z) :
  paths (((x : X) * Y x) -> Z) (uncurry X Y Z (curry X Y Z f)) f = <_> f

curry_uncurry (X : U) (Y : X -> U) (Z : U) (f: (x:X) -> Y x -> Z) :
  paths ((x : X) -> Y x -> Z) (curry X Y Z (uncurry X Y Z f)) f = <_> f

-- ============= Iteration of an endomorphism =============

iteration (T : U) (f : T -> T) : nat -> T -> T = split
  zero  -> idfun T
  suc n -> funcomp T T T f (iteration T f n)

-- ============= Basic constructions related to the adjoint evaluation =============
-- function X -> ((X -> Y) -> Y)

adjev (X Y : U) (x : X) (f : X -> Y) : Y = f x

adjev2 (X Y : U) (phi : ((X -> Y) -> Y) -> Y) : X -> Y =
  \(x : X) -> phi (\(f : X -> Y) -> f x)

-- ============= Pairwise direct products =============
dirprod (X Y : U) : U = (x:X) * Y

dirprod_pr1 (X Y : U) (p : dirprod X Y) : X = p.1
dirprod_pr2 (X Y : U) (p : dirprod X Y) : Y = p.2

dirprodpair (X Y : U) (x : X) (y : Y) : dirprod X Y = (x, y)

dirprodadj (X Y Z : U) (f : dirprod X Y -> Z) : X -> Y -> Z =
  curry X (\(x : X) -> Y) Z f
-- \(x : X) (y : Y) -> f (dirprodpair X Y x y)

dirprodf (X Y X' Y' : U)
  (f : X -> Y) (f' : X' -> Y') (xx' : dirprod X X') : dirprod Y Y' =
  (f xx'.1, f' xx'.2)

ddualand (X Y P : U)
  (xp : (X -> P) -> P) (yp : (Y -> P) -> P) (X0 : dirprod X Y -> P) : P =
  xp (\(x : X) -> yp (\(y : Y) -> X0 (x, y)))

-- ============= Negation and double negation =============

neg (X : U) : U = X -> empty

neq (X : U) (x y : X) : U = neg (paths X x y)

negf (X Y : U) (f : X -> Y) : neg Y -> neg X =
  \(ny : neg Y)(x : X) -> ny (f x)

dneg (X : U) : U = neg (neg X)

dnegf (X Y : U) (f : X -> Y) : dneg X -> dneg Y =
  negf (neg Y) (neg X) (negf X Y f)

todneg (X : U) : X -> dneg X = adjev X empty

dnegnegtoneg (X : U) : dneg (neg X) -> neg X = adjev2 X empty

dneganddnegl1 (X Y : U) (dnx : dneg X) (dny : dneg Y) :
  neg (X -> neg Y) = \(X2 : X -> neg Y) -> dnegf X (neg Y) X2 dnx dny

dneganddnegimpldneg (X Y : U) (dnx : dneg X) (dny : dneg Y) :
  dneg (dirprod X Y) = ddualand X Y empty dnx dny

-- ============= Logical equivalence =============

logeq (X Y : U) : U = dirprod (X -> Y) (Y -> X)

isrefl_logeq (X : U) : logeq X X = (idfun X, idfun X)

issymm_logeq (X Y : U) (p : logeq X Y) : (logeq Y X) = (p.2, p.1)

logeqnegs (X Y : U) (l : logeq X Y ) : logeq (neg X) (neg Y) =
  (negf Y X l.2, negf X Y l.1)

logeq_both_true (X Y : U) : X -> Y -> (logeq X Y) =
  \(x : X)(y : Y) -> (\(x : X) -> y, \(y : Y) -> x)

logeq_both_false (X Y : U) : neg X -> neg Y -> (logeq X Y) =
  \(nx : neg X)(ny : neg Y) ->
    (\(x : X) -> fromempty Y (nx x)
    ,\(y : Y) -> fromempty X (ny y) )

logeq_trans (X Y Z : U) (lxy : logeq X Y) (lyz : logeq Y Z) : logeq X Z =
  (funcomp X Y Z lxy.1 lyz.1, funcomp Z Y X lyz.2 lxy.2)

-- ============= Operations on paths =============
-- ============= Composition of paths and inverse paths =============

pathscomp0 (X : U) (a b c : X) (e1 : paths X a b) (e2 : paths X b c) :
  paths X a c = <i> comp (<_> X) (e1 @ i) [(i=0) -> <_> a, (i=1) -> <j> e2 @ j]
-- This is an equivalent definition
-- transport (<i> paths X a (e2 @ i)) e1

pathscomp0rid (X : U) (a b : X) (e1 : paths X a b) :
  paths (paths X a b) (pathscomp0 X a b b e1 (<_> b)) e1 =
  <i j> fill (<_> X) (e1 @ j) [(j=0) -> <_> a,(j=1) -> <_> b] @ -i
-- This is an equivalent definition.
-- <j i> comp (<_> X) (e1 @ i) [(j = 1) -> <_> e1 @ i,(i=0) -> <_> a, (i=1) -> <_> b]

-- This is trivial in the original UniMath, but not in this setting. Is there a better way to prove this.
pathscomp0lid (X : U) (a b : X) (e1 : paths X a b)
  : paths (paths X a b) e1 (pathscomp0 X a a b (<_> a) e1)
  = paths_rect X a
      (\(x : X)(p : paths X a x) -> paths (paths X a x) p (pathscomp0 X a a x (<_> a) p))
      (<i> pathscomp0rid X a a (<_> a) @ -i) b e1

{- An alternative definition. Is there a shorter purely-cubical proof?
  <j i> comp (<_> X) (s @ i @ -j)
                     [(i=0) -> <k> a
                     ,(i=1) -> <k> c @ -j \/ k
                     ,(j=0) -> <k> e1 @ i
                     ,(j=1) -> <k> c @ i /\ k ]
  where
  c : paths X a b = pathscomp0 X a a b (<_> a) e1
  
  s : IdP (<k> paths X a (e1 @ k)) (<_> a) c
    = <j i> fill (<_> X) a [(i = 0) -> <_> a, (i=1) -> <k> e1 @ k] @ j
-}

-- Note: This should generally be avoided, unless the type of path cannot be inffered
pathsinv0 (X : U) (a b : X) (e : paths X a b) : paths X b a = <i> e @ -i    

-- Note, multiple instances of pathscomp0 should be avoided, as they are hard to manipulate.
--   This may not be an apropriate theorem for a cubical version of the library, and shouldn't be used.
path_assoc (X : U) (a b c d : X) (f : paths X a b) (g : paths X b c) (h : paths X c d)
  : paths (paths X a d) (pathscomp0 X a b d f (pathscomp0 X b c d g h))
                        (pathscomp0 X a c d (pathscomp0 X a b c f g) h)
  = paths_rect X c
      (\(x : X)(p : paths X c x) ->
        paths (paths X a x) (pathscomp0 X a b x f (pathscomp0 X b c x g p))
                            (pathscomp0 X a c x (pathscomp0 X a b c f g) p) )
      (pathscomp0 (paths X a c)
                  (pathscomp0 X a b c f (pathscomp0 X b c c g (<_> c)))
                  (pathscomp0 X a b c f g)
                  (pathscomp0 X a c c (pathscomp0 X a b c f g) (<_> c))
                  (<i> pathscomp0 X a b c f (pathscomp0rid X b c g @ i))
                  (<i> pathscomp0rid X a c (pathscomp0 X a b c f g) @ -i) )
      d h

-- Is there a better way to prove this?
pathsinv0l (X : U) (a b : X) (e : paths X a b)
  : paths (paths X a a) (pathscomp0 X a b a e (<i> e @ -i)) (<_> a)
  = paths_rect X a
      (\(x : X)(p : paths X a x) -> paths (paths X a a) (pathscomp0 X a x a p (<i> p @ -i)) (<_> a))
      (pathscomp0rid X a a (<_> a)) b e

-- Is there a better way to prove this?
pathsinv0r (X : U) (a b : X) (e : paths X a b)
  : paths (paths X b b) (pathscomp0 X b a b (<i> e @ -i) e) (<_> b)
  = paths_rect X a
      (\(x : X)(p : paths X a x) -> paths (paths X x x) (pathscomp0 X x a x (<i> p @ -i) p) (<_> x))
      (pathscomp0rid X a a (<_> a)) b e

pathsinv0inv0 (X : U) (x x' : X) (e : paths X x x')
  : paths (paths X x x') (<j> (pathsinv0 X x x' e) @ -j) e = <_> e

-- Is there a better way to prove this?
pathscomp_cancel_left (X:U) (x y z : X) (p: paths X x y) (r s : paths X y z)
  : paths (paths X x z) (pathscomp0 X x y z p r) (pathscomp0 X x y z p s) -> paths (paths X y z) r s
  = paths_rect X y
      (\(x : X)(p : paths X y x) ->
        paths (paths X x z) (pathscomp0 X x y z (<i> p @ -i) r) (pathscomp0 X x y z (<i> p @ -i) s) -> paths (paths X y z) r s )
      f x (<i> p @ -i)
  where
  f (prs : paths (paths X y z) (pathscomp0 X y y z (<_> y) r) (pathscomp0 X y y z (<_> y) s)) :
    paths (paths X y z) r s =
    transport (<i> paths (paths X y z) (pathscomp0lid X y z r @ -i) (pathscomp0lid X y z s @ -i)) prs

-- Is there a better way to prove this?
pathscomp_cancel_right (X:U) (x y z : X) (p q: paths X x y) (s : paths X y z)
  : paths (paths X x z) (pathscomp0 X x y z p s) (pathscomp0 X x y z q s) -> paths (paths X x y) p q
  = paths_rect X y
      (\(z : X)(s : paths X y z) ->
        paths (paths X x z) (pathscomp0 X x y z p s) (pathscomp0 X x y z q s) -> paths (paths X x y) p q)
      f z s
  where
  f (pqs : paths (paths X x y) (pathscomp0 X x y y p (<_> y)) (pathscomp0 X x y y q (<_> y)))
    : paths (paths X x y) p q
    = transport (<i> paths (paths X x y) (pathscomp0rid X x y p @ i) (pathscomp0rid X x y q @ i)) pqs

-- ============= Direct product of paths ============= 

pathsdirprod (X Y : U) (x1 x2 : X) (y1 y2 : Y) (ex : paths X x1 x2) (ey : paths Y y1 y2) 
  : paths ((_ : X) * Y) (x1, y1) (x2, y2) 
  = <i> (ex @ i, ey @ i)

-- ============= The function maponpaths between paths types defined by a =============
-- function between ambient types and its behavior relative to @ and !

-- Note: unless the type of the path cannot be inffered, this should generally be avoided
maponpaths (T1 T2 : U) (f : T1 -> T2) (t1 t2 : T1) (e : paths T1 t1 t2)
  : paths T2 (f t1) (f t2) = <i> f (e @ i)

-- Is there a better way to prove this?
maponpathscomp0 (X Y : U) (x1 x2 x3 : X) (f : X -> Y) (e1 : paths X x1 x2) (e2 : paths X x2 x3)
  : paths (paths Y (f x1) (f x3))
      (<i> f (pathscomp0 X x1 x2 x3 e1 e2 @ i))
      (pathscomp0 Y (f x1) (f x2) (f x3) (<i> f (e1 @ i)) (<i> f (e2 @ i)))
  = <j i> comp (<_> Y) (f (e1 @ i))
                       [(i=0) -> <k> f x1
                       ,(i=1) -> <k> f (e2 @ k)
                       ,(j=0) -> <k> f (fill (<_> X) (e1 @ i) [(i=0) -> <_> x1, (i=1) -> e2] @ k)
                       ,(j=1) -> <k> fill (<_> Y) (f (e1 @ i)) [(i=0) -> <_> f x1, (i=1) -> <k> f (e2 @ k)] @ k ]

maponpathsinv0 (X Y : U) (f : X -> Y) (x1 x2 : X) (e : paths X x1 x2)
               : paths (paths Y (f x2) (f x1))
                       (maponpaths X Y f x2 x1 (<i> e @ -i))
                       (<i> maponpaths X Y f x1 x2 e @ -i)
               = <_ i> f (e @ -i)

-- ============= maponpaths for the identity functions and compositions of functions ============= 

maponpathsidfun (X : U) (x x' : X) (e : paths X x x')
  : paths (paths X x x') (<i> (idfun X) (e @ i)) e
  = <_> e

maponpathscomp (X Y Z : U) (x x' : X) (f : X -> Y) (g : Y -> Z) (e : paths X x x')
  : paths (paths Z (g (f x)) (g (f x'))) (<i> g (maponpaths X Y f x x' e @ i))
                                         (<i> (funcomp X Y Z f g) (e @ i))
  = <_ i> g (f (e @ i))

-- naturality of maponpaths

maponpaths_naturality (X Y : U) (f:X->Y) (x x' x'':X) (p:paths X x x') (q: paths X x' x'')
           (p':paths Y (f x) (f x')) (q':paths Y (f x') (f x''))
           (r:paths (paths Y (f x) (f x'))   (<i> f (p @ i)) p')
           (s:paths (paths Y (f x') (f x'')) (<i> f (q @ i)) q')
  : paths (paths Y (f x) (f x'')) (<i> f (pathscomp0 X x x' x'' p q @ i))
                                  (pathscomp0 Y (f x) (f x') (f x'') p' q')
  = transport (<i> paths (paths Y (f x) (f x''))
                         (<i> f (pathscomp0 X x x' x'' p q @ i))
                         (pathscomp0 Y (f x) (f x') (f x'') (r @ i) (s @ i))  )
              (maponpathscomp0 X Y x x' x'' f p q)

maponpaths_naturality' (X Y:U) (f:X->Y) (x x' x'':X) (p:paths X x' x) (q:paths X x' x'')
           (p':paths Y (f x') (f x)) (q':paths Y (f x') (f x''))
           (r:paths (paths Y (f x') (f x))   (<i> f (p @ i)) p')
           (s:paths (paths Y (f x') (f x'')) (<i> f (q @ i)) q')
  : paths (paths Y (f x) (f x'')) (<j> f (pathscomp0 X x x' x'' (<i> p @ -i) q @ j))
                                  (pathscomp0 Y (f x) (f x') (f x'') (<i> p' @ -i) q')
  = maponpaths_naturality X Y f x x' x'' (<i> p @ -i) q (<i> p' @ -i) q' (<i j> r @ i @ -j) s

{-
The following three statements show that maponpaths defined by a function f which is homotopic to the identity is "surjective". It is later used to show that the maponpaths defined by a function which is a weak equivalence is itself a weak equivalence.
-}

maponpathshomidinv (X : U) (f : X -> X)
  (h : (x : X) -> paths X (f x) x) (x x' : X) (e : paths X (f x) (f x')) : paths X x x' =
  <i> comp (<_> X) (e @ i) [(i=0) -> h x, (i=1) -> h x']
-- This is an alternative proof, closer to the one present in the original UniMath.
-- pathscomp0 X x (f x) x' (<i> h x @ -i) (pathscomp0 X (f x) (f x') x' e (h x'))
-- Note that the definition used here is far easier to reason about, as can be seen in maponpathshomid2.
--      that proof would fail, and would likely be far more complicated if the original definition were to be used.

maponpathshomid1 (X : U) (f : X -> X) (h : (x : X) -> paths X x (f x)) (x x' : X) (e : paths X x x')
  : paths (paths X (f x) (f x'))
          (<i> f (e @ i))
          (<i> comp (<_> X) (e @ i) [(i=0) -> h x, (i=1) -> h x'])
  = <j i> comp (<_> X) (e @ i) [(i = 0) -> h x, (i = 1) -> h x', (j = 0) -> h (e @ i)]

-- Is there a better way to prove this?
maponpathshomid2 (X : U) (f : X -> X) (h: (x : X) -> paths X (f x) x) (x x' : X) (e: paths X (f x) (f x'))
  : paths (paths X (f x) (f x')) (<i> f (maponpathshomidinv X f h x x' e @ i)) e
  = <j i> comp (<_> X) (maponpathshomidinv X f h x x' e @ i)
                       [(i=0) -> <k> h x @ -k
                       ,(i=1) -> <k> h x' @ -k
                       ,(j=0) -> <k> h (maponpathshomidinv X f h x x' e @ i) @ -k
                       ,(j=1) -> <k> fill (<_> X) (e @ i) [(i=0) -> h x, (i=1) -> h x'] @ -k ]

-- Here we consider the behavior of maponpaths in the case of a projection p with a section s.

pathssec1 (X Y : U) (s : X -> Y) (p : Y -> X) (eps : (x : X) -> paths X (p (s x)) x)
  (x : X) (y : Y) (e : paths Y (s x) y) : paths X x (p y)
  = <i> comp (<_> X) (p (e @ i)) [(i=0) -> eps x, (i=1) -> <_> p y]

pathssec2 (X Y : U) (s : X -> Y) (p : Y -> X) (eps : (x : X) -> paths X (p (s x)) x)
  (x x' : X) (e : paths Y (s x) (s x')) : paths X x x'
  = <i> comp (<_> X) (p (e @ i)) [(i=0) -> eps x, (i=1) -> eps x']

pathssec2id (X Y : U) (s : X -> Y) (p : Y -> X) (eps : (x : X) -> paths X (p (s x)) x) (x : X)
  : paths (paths X x x) (pathssec2 X Y s p eps x x (<_> (s x))) (<_> x)
  = <j i> comp (<_> X) (p (s x)) [(i = 0) -> eps x, (i = 1) -> eps x, (j = 1) -> eps x] 

pathssec3 (X Y : U) (s : X -> Y) (p : Y -> X) (eps : (x : X) -> paths X (p (s x)) x)
  (x x' : X) (e : paths X x x') : paths (paths X x x') (pathssec2 X Y s p eps x x' (<i> s (e @ i))) e
  = <j i> comp (<_> X) (p (s (e @ i))) [(i = 0) -> eps x, (i = 1) -> eps x', (j = 1) -> eps (e @ i)]

map_on_two_paths (X Y Z : U) (f:X -> Y -> Z) (x x' : X) (y y' : Y) 
  (px : paths X x x') (py : paths Y y y') : paths Z (f x y) (f x' y') = <i> f (px @ i) (py @ i)
  
-- ============= Fibrations and paths =============

tppr (T : U) (P : T -> U) (x : total2 T P) : paths (total2 T P) x (x.1, x.2) = <_> x

constr1 (X : U) (P : X -> U) (x x' : X) (e : paths X x x')
  : (f : P x -> P x') *
    (ee : (p : P x) -> paths (total2 X P) (x, p) (x', f p)) *
    (pp : P x) -> paths (paths X x x') (<i> (ee pp @ i).1) e
  = (\(p : P x) -> transport (<i> P (e @ i)) p
    ,\(p : P x) -> <i> (e @ i, fill (<j> P (e @ j)) p [] @ i)
    ,\(p : P x) -> <_> e)
{- This is the way it's done in the original library, but I think my way is better.
    paths_rect X x
      (\(x':X)(e:paths X x x') -> (f:P x->P x') * (ee : (p : P x) -> paths (total2 X P) (x, p) (x', f p)) *
                                  (pp : P x) -> paths (paths X x x') (<i> (ee pp @ i).1) e )
      (idfun (P x), \(p:P x) -> <_> (x, p), \(p:P x) -> <_ _> x) x' e
-}

-- Note: Generally, this should be avoided in favor of the built-in notation.
transportf (X : U) (P : X -> U) (x x' : X) (e : paths X x x') (px : P x) : P x' = transport (<i> P (e @ i)) px
-- This definition is closer to what's presented in the original library
-- (constr1 X P x x' e).1

-- Note: Generally, this should be avoided in favor of the built-in notation.
transportb (X : U) (P : X -> U) (x x' : X) (e : paths X x x') (px : P x') : P x = transport (<i> P (e @ -i)) px
-- This definition is closer to what's presented in the original library
-- transportf X P x' x (pathsinv0 X x x' e)

dpath_transportf (X : U) (P:X->U) (x:X) (p:P x) : paths (P x) p (transport (<i> P x) p) = fill (<_> P x) p []

-- Note: This theorem is trivial both in statement and in proof in CubicalTT, even if we
--       strictly follow how it's done in the original UniMath.
functtransportf (X Y : U) (f : X -> Y) (P : Y -> U) (x x' : X) (e : paths X x x') (p : P (f x))
  : paths (P (f x')) (transport (<i> P (f (e @ i))) p) (transport (<i> P (f (e @ i))) p)
  = <_> transport (<i> P (f (e @ i))) p

-- Note: This theorem is trivial both in statement and in proof in CubicalTT, even if we
--       strictly follow how it's done in the original UniMath.
functtransportb (X Y : U) (f : X -> Y) (P : Y -> U) (x x' : X) (e : paths X x' x) (p : P (f x))
  : paths (P (f x')) (transport (<i> P (f (e @ -i))) p) (transport (<i> P (f (e @ -i))) p)
  = <_> transport (<i> P (f (e @ -i))) p

-- Is there a better way to prove this?
transport_f_b (X : U) (P : X -> U) (x y z : X) (e : paths X y x) (e' : paths X y z) (p : P x)
  : paths (P z) (transport (<i> P (e' @ i)) (transport (<i> P (e @ -i)) p))
                (transport (<i> P (pathscomp0 X x y z (<j> e @ -j) e' @ i)) p)
  = paths_rect X y
      (\(z : X)(e' : paths X y z) ->
        paths (P z) (transport (<i> P (e' @ i)) (transport (<i> P (e @ -i)) p))
                    (transport (<i> P (pathscomp0 X x y z (<j> e @ -j) e' @ i)) p)  )
      (<i> comp (<j> P (fill (<_> X) (e @ -j /\ i) [(j=0) -> <_> e @ i,(j=1) -> <_> y] @ i))
               (fill (<j> P (e @ -j)) p [] @ -i) [])
      z e'

transport_b_f (X : U) (P : X -> U) (x y z : X) (e : paths X x y) (e' : paths X z y) (p : P x)
  : paths (P z)
          (transport (<i> P (e' @ -i)) (transport (<i> P (e @ i)) p))
          (transport (<j> P (pathscomp0 X x y z e (<i> e' @ -i) @ j)) p)
  = transport_f_b X P x y z (<i> e @ -i) (<i> e' @ -i) p

transport_f_f (X : U) (P : X -> U) (x y z : X) (e : paths X x y) (e' : paths X y z) (p : P x)
  : paths (P z) (transport (<i> P (e' @ i)) (transport (<i> P (e @ i)) p)) (transport (<i> P (pathscomp0 X x y z e e' @ i)) p)
  = transport_f_b X P x y z (<i> e @ -i) e' p

-- Is there a better way to do this?
transport_b_b (X : U) (P : X -> U) (x y z : X) (e : paths X x y) (e' : paths X y z) (p : P z)
  : paths (P x) (transport (<i> P (e @ -i)) (transport (<i> P (e' @ -i)) p))
                (transport (<i> P (pathscomp0 X x y z e e' @ -i)) p)
  = paths_rect X y
      (\(x : X)(e : paths X y x) ->
         paths (P x) (transport (<i> P (e @ i)) (transport (<i> P (e' @ -i)) p))
                     (transport (<j> P (pathscomp0 X x y z (<i> e @ -i) e' @ -j)) p)  )
      d x (<i> e @ -i)
  where
  d2 : paths (P z) (transport (<_> P z) (transport (<_> P z) p))
                   (transport (<i> P (pathscomp0 X z z z (<_> z) (<_> z) @ i)) p)
     = <i> comp (<j> P (pathscomp0rid X z z (<_> z) @ -i @ j)) (fill (<_> P z) p [] @ -i) []
  
  d : paths (P y) (transport (<_> P y) (transport (<i> P (e' @ -i)) p))
                  (transport (<i> P (pathscomp0 X y y z (<_> y) e' @ -i)) p)
    = paths_rect X z
        (\(y : X)(e' : paths X z y) ->
           paths (P y) (transport (<_> P y) (transport (<i> P (e' @ i)) p))
                       (transport (<j> P (pathscomp0 X y y z (<_> y) (<i> e' @ -i) @ -j)) p) )
        d2 y (<i> e' @ -i)

-- Is there a better way to prove this?
transport_map (X : U) (P Q : X -> U) (f : (x : X) -> P x -> Q x) (x y : X) (e : paths X x y) (p : P x)
  : paths (Q y) (transport (<i> Q (e @ i)) (f x p)) (f y (transport (<i> P (e @ i)) p))
  = paths_rect X x
      (\(y : X)(e : paths X x y) ->
         paths (Q y) (transportf X Q x y e (f x p)) (f y (transportf X P x y e p))  )
      (<i> comp (<_> Q x) (fill (<_> Q x) (f x p) [] @ -i)
                          [(i=0) -> <_> comp (<_> Q x) (f x p) []
                          ,(i=1) -> <j> f x (fill (<_> P x) p [] @ j) ] )
      y e

transport_section (X : U) (P : X -> U) (f: (x : X) -> P x) (x y : X) (e : paths X x y)
  : paths (P y) (transportf X P x y e (f x)) (f y)
  = transport_map X (\(x : X) -> unit) P (\(x : X)(px : unit) -> f x) x y e tt

-- A series of lemmas about paths and sigma types. Adapted from the HoTT library http://github.com/HoTT/HoTT

-- Generally avoid using this.
base_paths (A : U) (B : A -> U) (a b : total2 A B) (p : paths (total2 A B) a b)
  : paths A a.1 b.1
  = <i> (p @ i).1

-- This is the version of the theorem used in the original library, don't use it.
total2_paths_OLD (A : U) (B : A -> U) (s s' : (x : A) * B x)
    (p : paths A s.1 s'.1)
    (q : paths (B s'.1) (transportf A B s.1 s'.1 p s.2) s'.2)
  : paths ((x : A) * B x) s s'
  = <i> (p @ i, d @ i)
  where
  d : IdP (<i> B (p @ i)) s.2 s'.2
    = <i> comp (<_> B (p @ i))
               (fill (<j> B (p @ j)) s.2 [] @ i)
               [(i = 0) -> <_> s.2, (i = 1) -> q]

-- This is a theorem only here since it's present in the original library, don't use it.
total2_paths_b (A : U) (B : A -> U) (s s' : (x : A) * B x)
    (p : paths A s.1 s'.1)
    (q : paths (B s.1) s.2 (transportb A B s.1 s'.1 p s'.2))
  : paths ((x : A) * B x) s s'
  = <i> (p @ i, d @ -i)
  where
  d : IdP (<i> B (p @ -i)) s'.2 s.2
    = <i> comp (<_> B (p @ -i))
               (fill (<j> B (p @ -j)) s'.2 [] @ i)
               [(i = 0) -> <_> s'.2, (i = 1) -> <i> q @ -i]

-- Generally avoid using this, except when something fails to infer.
total2_paths (A : U) (B : A -> U) (s s' : (x : A) * B x)
    (p : paths A s.1 s'.1)
    (q : IdP (<i> B (p @ i)) s.2 s'.2)
  : paths ((x : A) * B x) s s'
  = <i> (p @ i, q @ i)

total2_paths2 (A : U) (B : A -> U) (a1 : A) (b1 : B a1) (a2 : A) (b2 : B a2)
    (p : paths A a1 a2)
    (q : IdP (<i> B (p @ i)) b1 b2)
  : paths ((x : A) * B x) (a1, b1) (a2, b2)
  = <i> (p @ i, q @ i)

pair_path_in2 (X : U) (P:X -> U) (x:X) (p q:P x) (e:paths (P x) p q)
  : paths ((x : X) * P x) (x, p) (x, q)
  = <i> (x, e @ i)

-- Generally avoid using this
fiber_paths (A : U) (B : A -> U) (u v : (x : A) * B x) (p : paths ((x : A) * B x) u v)
  : IdP (<i> B (p @ i).1) u.2 v.2
  = <i> (p @ i).2

total2_fiber_paths (A : U) (B : A -> U) (x y : (x : A) * B x) (p : paths (total2 A B) x y)
  : IdP (<_> paths (total2 A B) x y) (<i> ((p @ i).1, (p @ i).2)) p
  = <_> p

base_total2_paths (A : U) (B : A -> U) (x y : (x : A) * B x)
    (p : paths A x.1 y.1)
    (q : IdP (<i> B (p @ i)) x.2 y.2)
  : paths (paths A x.1 y.1) (<i> (total2_paths A B x y p q @ i).1) p
  = <_> p

-- Note that, due to theorems like base_total2_paths being trivial here,
--   much of the structure of this theorem collapses.
transportf_fiber_total2_paths (A : U) (B : A -> U) (x y : (x : A) * B x)
    (p : paths A x.1 y.1)
    (q : IdP (<i> B (p @ i)) x.2 y.2)
  : paths (IdP (<i> B (p @ i)) x.2 y.2)
          (transport (<i> IdP (<j> B (p @ j)) x.2 y.2)
                     (<i> (total2_paths A B x y p q @ i).2) )
          q
  = <j i> fill (<_> B (p @ i)) (q @ i) [(i = 0) -> <_> x.2, (i = 1) -> <_> y.2 ] @ -j

-- Lemmas about transport Adapted from the HoTT library and the HoTT book

transportD (A : U) (B : A -> U) (C : (a : A) -> B a -> U)
    (x1 x2 : A) (p : paths A x1 x2) (y : B x1) (z : C x1 y)
  : C x2 (transport (<i> B (p @ i)) y)
  = transport (<i> C (p @ i) (fill (<j> B (p @ j)) y [] @ i)) z

transportf_total2 (A : U) (B : A -> U) (C : (a : A) -> B a -> U)
  (x1 x2 : A) (p : paths A x1 x2) (yz : (y : B x1) * C x1 y)
  : paths ((y : B x2) * C x2 y)
          (transport (<i> (y : B (p @ i)) * C (p @ i) y) yz)
          (transport (<i> B (p @ i)) yz.1
          ,transportD A B C x1 x2 p yz.1 yz.2)
  = <_> transport (<i> (y : B (p @ i)) * C (p @ i) y) yz

transportf_dirprod (A : U) (B B' : A -> U) (x x' : (a : A) * dirprod (B a) (B' a)) (p : paths A x.1 x'.1)
  : paths ((_ : B x'.1) * B' x'.1)
          (transport (<i>  (_ : B (p @ i)) * B' (p @ i)) x.2)
          (transport (<i> B (p @ i)) x.2.1
          ,transport (<i> B' (p @ i)) x.2.2)
  = <_> transport (<i>  (_ : B (p @ i)) * B' (p @ i)) x.2        

transportf_id1 (A : U) (a x1 x2 : A) (p : paths A x1 x2) (q : paths A a x1)
  : paths (paths A a x2)
          (transport (<i> paths A a (p @ i)) q)
          (pathscomp0 A a x1 x2 q p)
  = <_> pathscomp0 A a x1 x2 q p

-- Is there a better way to prove this?
transportf_id2 (A : U) (a x1 x2 : A) (p : paths A x1 x2) (q : paths A x1 a)
  : paths (paths A x2 a)
          (transport (<i> paths A (p @ i) a) q)
          (pathscomp0 A x2 x1 a (<i> p @ -i) q)
  = <i> comp (<_> paths A x2 a)
             (<j> comp (<_> A) x1 [ (j = 0) -> p, (j = 1) -> q ])
             [(i = 0) -> <k o> comp (<_> A) (q @ o /\ k) [(o = 0) -> p, (o = 1) -> <l> q @ l \/ k ]
             ,(i = 1) -> <k o> comp (<_> A) (p @ -o /\ k) [(o = 0) -> <l> p @ l \/ k, (o = 1) -> q ] ]

transportf_id3 (A : U) (x1 x2 : A) (p : paths A x1 x2) (q : paths A x1 x1)
  : paths (paths A x2 x2)
          (transport (<i> paths A (p @ i) (p @ i)) q)
          (<i> comp (<_> A) (q @ i) [(i=0) -> p, (i=1) -> p])
  = <_> transport (<i> paths A (p @ i) (p @ i)) q

-- ============= First homotopy notions ============= 
-- Homotopy between functions

-- It *might* be a good idea to avoid using homot in favor of using just its definition
homot (X : U) (P : X -> U) (f g : (x : X) -> P x) : U = (x : X) -> paths (P x) (f x) (g x)

homotcomp (X Y : U) (f f' f'' : X -> Y)
    (h : homot X (\(_:X)->Y) f f') (h' : homot X (\(_:X)->Y) f' f'')
  : homot X (\(_:X)->Y) f f''
  = \(x : X) -> pathscomp0 Y (f x) (f' x) (f'' x) (h x) (h' x)

invhomot (X Y : U) (f f' : X -> Y) (h : homot X (\(_:X)->Y) f f' )
  : homot X (\(_:X)->Y) f' f
  = \(x : X) -> <i> h x @ -i

funhomot (X Y Z : U) (f : X -> Y) (g g' : Y -> Z) (h : homot Y (\(_:Y)->Z) g g' )
  : homot X (\(_:X)->Z) (funcomp X Y Z f g) (funcomp X Y Z f g') 
  = \(x : X) -> h (f x)

homotfun (X Y Z : U) (f f' : X -> Y) (h : homot X (\(_:X)->Y) f f') (g : Y -> Z)
  : homot X (\(_:X)->Z) (funcomp X Y Z f g) (funcomp X Y Z f' g)
  = \(x : X) -> <i> g (h x @ i)

-- Contractibility, homotopy fibers etc.
-- Contractible types.

iscontr (T:U) : U = (cntr:T) * (t:T) -> paths T t cntr

iscontrpair (T : U)
  : (x : T) -> ((t : T) -> paths T t x) -> iscontr T
  = tpair T (\(x : T) -> (t : T) -> paths T t x)

iscontrpr1 (T : U) (k : iscontr T) : T = k.1

iscontrretract (X Y : U) (p : X -> Y) (s : Y -> X)
    (eps : (y : Y) -> paths Y (p (s y)) y) (is : iscontr X) : iscontr Y
  = (p is.1, \(t : Y) -> <i> comp (<_> Y) (p (is.2 (s t) @ i)) [(i=0) -> eps t, (i=1) -> <_> p is.1])

proofirrelevancecontr (X : U) (is : iscontr X) (x x' : X) : paths X x x'
  = <i> comp (<_> X) is.1 [(i=0) -> <i> is.2 x @ -i, (i=1) -> <i> is.2 x' @ -i]

-- Coconuses: spaces of paths which begin (coconusfromt) or end (coconustot) at a given point.

-- It *might* be a good idea to avoid using this in favor of using just its definition
coconusfromt (T : U) (t : T) : U = (t':T) * paths T t t'

coconusfromtpair (T : U) (t t' : T) (e : paths T t t') : coconusfromt T t = (t', e)

coconusfromtpr1 (T : U) (t : T) (k : coconusfromt T t) : T = k.1

-- It *might* be a good idea to avoid using this in favor of using just its definition
coconustot (T : U) (t : T) : U = (t':T) * paths T t' t

coconustotpair (T : U) (t t' : T) (e : paths T t' t) : coconustot T t = (t', e)

coconustotpr1 (T : U) (t : T) (k : coconustot T t) : T = k.1

-- Is there a better way to do this?
connectedcoconustot (T : U) (t : T) (c1 c2 : coconustot T t)
  : paths (coconustot T t) c1 c2
  = <i> (    comp (<_> T) t [(i=0) -> <k> c1.2 @ -k, (i=1) -> <k> c2.2 @ -k]
        ,<j> fill (<_> T) t [(i=0) -> <k> c1.2 @ -k, (i=1) -> <k> c2.2 @ -k] @ -j )

iscontrcoconustot (T : U) (t : T) : iscontr (coconustot T t)
  = ((t, <_> t), \(t' : coconustot T t) -> connectedcoconustot T t t' (t, <_> t))

-- Is there a better way to do this?
connectedcoconusfromt (T : U) (t : T) (c1 c2 : coconusfromt T t)
  : paths (coconusfromt T t) c1 c2
  = <i> (comp (<_> T) t [(i=0) -> c1.2, (i=1) -> c2.2]
        ,fill (<_> T) t [(i=0) -> c1.2, (i=1) -> c2.2] )

iscontrcoconusfromt (T : U) (t : T) : iscontr (coconusfromt T t)
  = ((t, <_> t), \(t' : coconusfromt T t) -> connectedcoconusfromt T t t' (t, <_> t))

-- Paths space of a type: a point t, and the coconus from it.

pathsspace (T : U) : U = (t : T) * coconusfromt T t

pathsspacetriple (T : U) (t1 t2 : T) (e : paths T t1 t2)
  : pathsspace T
  = (t1, (coconusfromtpair T t1 t2 e))

deltap (T : U) (t : T) : pathsspace T = pathsspacetriple T t t (<_> t)

pathsspace' (T : U) : U = (xy : (_:T) * T) * paths T xy.1 xy.2

-- Homotopy fibers.

hfiber (X Y : U) (f : X -> Y) (y : Y) : U = (x:X) * paths Y (f x) y

hfiberpair (X Y : U) (f : X -> Y) (y : Y) (x : X) (e : paths Y (f x) y)
  : hfiber X Y f y = (x, e)

hfiberpr1 (X Y : U) (f : X -> Y) (y : Y) (k : hfiber X Y f y) : X = k.1

-- Paths in homotopy fibers.

hfibertriangle1 (X Y : U) (f : X -> Y) (y : Y) (xe1 xe2 : hfiber X Y f y)
    (e : paths (hfiber X Y f y) xe1 xe2)
  : IdP (<i> paths Y (f (e @ i).1) y) xe1.2 xe2.2
  = <i> (e @ i).2

hfibertriangle1' (X Y : U) (f : X -> Y) (x : X) (xe1: hfiber X Y f (f x))
    (e : paths (hfiber X Y f (f x)) xe1 (x, <_> f x))
  : IdP (<i> paths Y (f (e @ i).1) (f x)) xe1.2 (<_> f x)
  = <i> (e @ i).2

-- Note : Due to the utilization of pathovers in this section, this theorem
--        becomes the same as hfibertriangle1
hfibertriangle1inv0 (X Y : U) (f : X -> Y) (y : Y) (xe1 xe2: hfiber X Y f y)
    (e : paths (hfiber X Y f y) xe1 xe2)
  : IdP (<i> paths Y (f (e @ i).1) y) xe1.2 xe2.2
  = <i> (e @ i).2

hfibertriangle1inv0' (X Y : U) (f : X -> Y) (x : X) (xe2: hfiber X Y f (f x))
    (e : paths (hfiber X Y f (f x)) (x, <_> (f x)) xe2)
  : IdP (<i> paths Y (f (e @ i).1) (f x)) (<_> f x) xe2.2
  = <i> (e @ i).2

hfibertriangle2 (X Y : U) (f : X -> Y) (y : Y) (xe1 xe2: hfiber X Y f y)
    (ee : paths X xe1.1 xe2.1)
    (eee: IdP (<i> paths Y (f (ee @ i)) y) xe1.2 xe2.2)
  : paths (hfiber X Y f y) xe1 xe2
  = <i> (ee @ i, eee @ i)

-- Coconus of a function: the total space of the family of h-fibers.
-- The coconus behaves like the image of a function.

coconusf (X Y : U) (f : X -> Y) : U = (y:Y) * hfiber X Y f y

fromcoconusf (X Y : U) (f : X -> Y) (yxe : coconusf X Y f) : X = yxe.2.1

tococonusf (X Y : U) (f : X -> Y) (x : X) : coconusf X Y f = (f x, x, (<_> f x)) 

homottofromcoconusf (X Y : U) (f : X -> Y) (yxe : coconusf X Y f)
  : paths (coconusf X Y f) (tococonusf X Y f (fromcoconusf X Y f yxe)) yxe
  = <i> (yxe.2.2 @ i, yxe.2.1, <j> yxe.2.2 @ i /\ j)

homotfromtococonusf (X Y : U) (f : X -> Y) (x : X)
  : paths X (fromcoconusf X Y f (tococonusf X Y f x)) x
  = <_> x

-- Total spaces of families and homotopies

famhomotfun (X : U) (P Q : X -> U) (h : homot X (\(x:X)->U) P Q) (xp : total2 X P)
  : total2 X Q
  = transport (<i> total2 X (\(x : X) -> h x @ i)) xp

famhomothomothomot (X : U) (P Q : X -> U) (h1 h2 : homot X (\(x:X)->U) P Q)
    (H : homot X (\(x : X) -> paths U (P x) (Q x)) h1 h2)
  : homot (total2 X P) (\(_ : total2 X P) -> total2 X Q) (famhomotfun X P Q h1) (famhomotfun X P Q h2)
  = \(xp : total2 X P) -> <i> famhomotfun X P Q (\(x : X) -> H x @ i) xp

-- ============= Weak equivalences =============
-- Basics

isweq (X Y : U) (f : X -> Y) : U = (y : Y) -> iscontr (hfiber X Y f y)

idisweq (T : U) : isweq T T (idfun T)
  = \(y : T) -> ((y, <_> y), \(t : hfiber T T (idfun T) y) -> <i> (t.2 @ i, <j> t.2 @ i \/ j))

weq (X Y : U) : U = (f:X->Y) * isweq X Y f

pr1weq (X Y : U) (eq : weq X Y) : X -> Y = eq.1

-- Note: At this point coercions are used. Often, in the original library,
--       f.1 would simply be denoted f.
weqproperty (X Y : U) (f : weq X Y) : isweq X Y f.1 = f.2

weqccontrhfiber (X Y : U) (w : weq X Y) (y : Y) : hfiber X Y w.1 y
  = (w.2 y).1

weqccontrhfiber2 (X Y : U) (w : weq X Y) (y : Y) (x : hfiber X Y w.1 y)
  : paths (hfiber X Y w.1 y) x (weqccontrhfiber X Y w y)
  = (w.2 y).2 x

weqpair (X Y : U) (f : X -> Y) (is : isweq X Y f) : weq X Y = (f, is)

idweq (X : U) : weq X X = (idfun X, idisweq X)

-- Is there a better way to do this?
eqweqmap (T1 T2 : U) (p : paths U T1 T2) : weq T1 T2
  = paths_rect U T1 (\(T2 : U)(p : paths U T1 T2) -> weq T1 T2) (idweq T1) T2 p

isweqtoempty (X : U) (f : X -> empty) : isweq X empty f
  = \(e : empty) -> fromempty (iscontr (hfiber X empty f e)) e

weqtoempty (X : U) (f : X -> empty) : weq X empty = (f, isweqtoempty X f)

isweqtoempty2 (X Y : U) (f : X -> Y) (is : neg Y) : isweq X Y f
  = \(y : Y) -> fromempty (iscontr (hfiber X Y f y)) (is y)

weqtoempty2 (X Y : U) (f : X -> Y) (is : neg Y) : weq X Y = (f, isweqtoempty2 X Y f is)

invmap (X Y : U) (w : weq X Y) (y : Y) : X = (weqccontrhfiber X Y w y).1
                                        -- = (w.2 y).1.1
{-
We now define different homotopies and maps between the paths spaces corresponding to a weak equivalence. What may look like unnecessary complexity in the definition of homotinvweqweq is due to the fact that the "naive" definition needs to be corrected in order for lemma homotweqinvweqweq to hold.
-}

homotweqinvweq (X Y : U) (w : weq X Y) (y : Y) : paths Y (w.1 (invmap X Y w y)) y
  = (weqccontrhfiber X Y w y).2

homotinvweqweq0 (X Y : U) (w : weq X Y) (x : X) : paths X x (invmap X Y w (w.1 x))
  = <i> ((w.2 (w.1 x)).2 (x, <_> w.1 x) @ i).1

homotinvweqweq (X Y : U) (w : weq X Y) (x : X)
  : paths X (invmap X Y w (w.1 x)) x
  = <i> homotinvweqweq0 X Y w x @ -i

-- Is there a better 
diaglemma2 (X Y : U) (f : X -> Y) (x x' : X)
    (e1 : paths X x x') (e2 : paths Y (f x') (f x))
    (ee : IdP (<i> paths Y (f (e1 @ i)) (f x)) (<_> f x) e2)
  : paths (paths Y (f x') (f x)) (<i> f (e1 @ -i)) e2
  = <j i> comp (<_> Y) (f x) [(i=0) -> <k> f (e1 @ k)
                             ,(i=1) -> <_> f x
                             ,(j=0) -> <k> f (e1 @ k /\ -i)
                             ,(j=1) -> <k> ee @ k @ i ]

-- Is there a better way to prove this?
--   This proof follows very closely to that presented in the original library.
--   If there is a better proof, then it's probably specific to cubicaltt.
homotweqinvweqweq (X Y : U) (w : weq X Y) (x : X)
  : paths (paths Y (w.1 (invmap X Y w (w.1 x))) (w.1 x)) 
          (<i> w.1 (homotinvweqweq X Y w x @ i))
          (homotweqinvweq X Y w (w.1 x))
  = diaglemma2 X Y w.1 x ((w.2 (w.1 x)).1.1) (<i> ((w.2 (w.1 x)).2 hfid @ i).1) hfcc.2 hft1
  where
  hfid : hfiber X Y w.1 (w.1 x) = hfiberpair X Y w.1 (w.1 x) x (<_> w.1 x)
  hfcc : hfiber X Y w.1 (w.1 x) = weqccontrhfiber X Y w (w.1 x)
  
  hft1 : IdP (<i> paths Y (w.1 ((w.2 (w.1 x)).2 hfid @ i).1) (w.1 x)) hfid.2 hfcc.2
       = hfibertriangle1 X Y w.1 (w.1 x) hfid hfcc (weqccontrhfiber2 X Y w (w.1 x) hfid)

weq_transportf_adjointness (X Y : U) (w : weq X Y) (P : Y -> U) (x : X) (p : P (w.1 x))
  : paths (P (w.1 (invmap X Y w (w.1 x))))
          (transport (<i> P (w.1 (homotinvweqweq X Y w x @ -i))) p)
          (transport (<i> P (homotweqinvweq X Y w (w.1 x) @ -i)) p)
  = <i> comp (<j> P (homotweqinvweqweq X Y w x @ i @ -j)) p []

-- Note: This theorem apears to be the same as weq_transportf_adjointness.
--       I don't see why it would differ, even in the original library.
weq_transportb_adjointness (X Y : U) (w : weq X Y) (P : Y -> U) (x : X) (p : P (w.1 x))
   : paths (P (w.1 (invmap X Y w (w.1 x))))
           (transport (<i> P (w.1 (homotinvweqweq X Y w x @ -i))) p)
           (transport (<i> P (homotweqinvweq X Y w (w.1 x) @ -i)) p)
  = <i> comp (<j> P (homotweqinvweqweq X Y w x @ i @ -j)) p []

invmaponpathsweq (X Y : U) (w : weq X Y) (x x' : X)
  : paths Y (w.1 x) (w.1 x') -> paths X x x'
  = pathssec2 X Y w.1 (invmap X Y w) (homotinvweqweq X Y w) x x'

invmaponpathsweqid (X Y : U) (w : weq X Y) (x : X)
  : paths (paths X x x)
          (invmaponpathsweq X Y w x x (<_> w.1 x))
          (<_> x)
  = pathssec2id X Y w.1 (invmap X Y w) (homotinvweqweq X Y w) x

pathsweq1 (X Y : U) (w : weq X Y) (x : X) (y : Y)
  : paths Y (w.1 x) y -> paths X x (invmap X Y w y)
  = pathssec1 X Y w.1 (invmap X Y w) (homotinvweqweq X Y w) x y

pathsweq1' (X Y : U) (w : weq X Y) (x : X) (y : Y) (e : paths X x (invmap X Y w y))
  : paths Y (w.1 x) y
  = <i> comp (<_> Y) (w.1 (e @ i)) [(i=0) -> <_> w.1 x
                                   ,(i=1) -> homotweqinvweq X Y w y ]

pathsweq3 (X Y : U) (w : weq X Y) (x x' : X) (e : paths X x x')
  : paths (paths X x x')
          (invmaponpathsweq X Y w x x' (<i> w.1 (e @ i)))
          e
  = pathssec3 X Y w.1 (invmap X Y w) (homotinvweqweq X Y w) x x' e

-- Is there a better way to prove this?
--   This proof follows very closely to what's in the original library, but this seems a bit ridiculous.
pathsweq4 (X Y : U) (w : weq X Y) (x x' : X) (e : paths Y (w.1 x) (w.1 x'))
  : paths (paths Y (w.1 x) (w.1 x'))
          (<i> w.1 (invmaponpathsweq X Y w x x' e @ i))
          e
  = <i> comp (<_> paths Y (f x) (f x')) (e5 @ i) [(i=0) -> e4, (i=1) -> e1]
  where
  f : X -> Y = w.1
  g : Y -> X = invmap X Y w
  
  ee : paths X (g (f x)) (g (f x')) = <i> g (e @ i)

  eee : paths X x x'
      = maponpathshomidinv X (funcomp X Y X f g) (homotinvweqweq X Y w) x x' ee

  e1 : paths (paths Y (f x) (f x')) (<i> f (eee @ i)) e
     = pathssec2 (paths Y (f x) (f x')) (paths X (g (f x)) (g (f x')))
                 s p eps
                 (<i> f (eee @ i)) e e3
     where
     e2lem (x : X) : paths X (g (f x)) x
        = <i> ((w.2 (f x)).2 (x, <_> f x) @ -i).1
    
     e2 : paths (paths X (g (f x)) (g (f x'))) (<i> g (f (eee @ i))) ee
        = maponpathshomid2 X (funcomp X Y X f g) e2lem x x' ee

     e3 : paths (paths X (g (f x)) (g (f x'))) (<i> g (f (eee @ i))) (<i> g (e @ i))
        = <i> comp (<_> paths X (g (f x)) (g (f x'))) (e2 @ i)
                   [(i=0) -> <_> e2 @ 0, (i=1) -> <_ k> (w.2 (e @ k)).1.1 ]

     s : paths Y (f x) (f x') -> paths X (g (f x)) (g (f x')) = maponpaths Y X g (f x) (f x')

     p : paths X (g (f x)) (g (f x')) -> paths Y (f x) (f x') = pathssec2 Y X g f (homotweqinvweq X Y w) (f x) (f x')

     eps : (e : paths Y (f x) (f x')) -> paths (paths Y (f x) (f x')) (p (s e)) e
         = pathssec3 Y X g f (homotweqinvweq X Y w) (f x) (f x')
  
  e4 : paths (paths Y (f x) (f x'))
             (<j> f (invmaponpathsweq X Y w x x' (<i> f (eee @ i)) @ j))
             (<i> f (invmaponpathsweq X Y w x x' e @ i))
     = <j i> f (invmaponpathsweq X Y w x x' (e1 @ j) @ i)

  X0 : paths (paths X x x')
             (invmaponpathsweq X Y w x x' (<i> f (eee @ i)))
             eee
     = pathsweq3 X Y w x x' eee
  
  e5 : paths (paths Y (f x) (f x'))
             (<j> f (invmaponpathsweq X Y w x x' (<i> f (eee @ i)) @ j))
             (<i> f (eee @ i))
     = <j i> f (X0 @ j @ i)

-- Weak equivalences between contractible types (other implications are proved below).

iscontrweqb (X Y : U) (w : weq X Y) : iscontr Y -> iscontr X
  = iscontrretract Y X (invmap X Y w) w.1 (homotinvweqweq X Y w)

-- Functions between fibers defined by a path on the base are weak equivalences.

-- Is there a better way to prove this?
isweqtransportf (X : U) (P : X -> U) (x x' : X) (e : paths X x x')
  : isweq (P x) (P x') (transportf X P x x' e)
  = paths_rect X x (\(x' : X)(e : paths X x x') -> isweq (P x) (P x') (transportf X P x x' e)) d x' e
  where
  p : paths (P x -> P x) (idfun (P x)) (transportf X P x x (<_> x))
    = <j> \(px : P x) -> fill (<_> P x) px [] @ j
  
  d : isweq (P x) (P x) (transportf X P x x (<_> x))
    = transport (<i> isweq (P x) (P x) (p @ i)) (idisweq (P x))

isweqtransportb (X : U) (P : X -> U) (x x' : X) (e : paths X x x')
  : isweq (P x') (P x) (transportb X P x x' e)
  = isweqtransportf X P x' x (<i> e @ -i)

-- unit and contractibility
-- unit is contractible (recall that tt is the name of the canonical term of the type unit ).

isconnectedunit : (x x' : unit) -> paths unit x x' = split
  tt -> helper where
    helper : (x' : unit) -> paths unit tt x' = split
      tt -> <_> tt

unitl0 (p : paths unit tt tt) : coconustot unit tt = (tt, p)

unitl1 (c : coconustot unit tt) : paths unit tt tt
  = transport (<i> paths unit (isconnectedunit c.1 tt @ i) tt) c.2

unitl2 (e : paths unit tt tt) : paths (paths unit tt tt) (unitl1 (unitl0 e)) e
  = <i j> fill (<_> unit) (e @ j) [ (j = 0) -> <_> tt, (j = 1) -> <_> tt ] @ -i

unitl3 (e : paths unit tt tt) : paths (paths unit tt tt) e (<_> tt)
  = <i> comp (<_> paths unit tt tt) (unitl1 (connectedcoconustot unit tt (unitl0 (<_> tt)) (unitl0 e) @ -i))
                                    [(i = 0) -> unitl2 e
                                    ,(i = 1) -> unitl2 (<_> tt)]

iscontrunit : iscontr unit = (tt, \(t : unit) -> isconnectedunit t tt)

-- paths in unit are contractible.

iscontrpathsinunit : (x x' : unit) -> iscontr (paths unit x x') = split
  tt -> helper where
    helper : (x' : unit) -> iscontr (paths unit tt x') = split
      tt -> (<_> tt, \(ptt : paths unit tt tt) -> unitl3 ptt)

-- A type T : UU is contractible if and only if T -> unit is a weak equivalence.

ifcontrthenunitl0 (e1 e2 : paths unit tt tt) : paths (paths unit tt tt) e1 e2
  = <i> comp (<_> paths unit tt tt) (<_> tt) [(i=0) -> <k> unitl3 e1 @ -k, (i=1) -> <k> unitl3 e2 @ -k ]

isweqcontrtounit (T : U) (is : iscontr T) : isweq T unit (\(t : T) -> tt) = split
  tt -> ((is.1, <_> tt), \(t : hfiber T unit (\(t : T) -> tt) tt) -> <i> (is.2 t.1 @ i , unitl3 t.2 @ i))

weqcontrtounit (T : U) (is : iscontr T) : weq T unit = (\(t : T) -> tt, isweqcontrtounit T is)

iscontrifweqtounit (X : U) (w : weq X unit) : iscontr X = iscontrweqb X unit w iscontrunit

-- A homotopy equivalence is a weak equivalence

hfibersgftog (X Y Z : U) (f : X -> Y) (g : Y -> Z) (z : Z) (xe : hfiber X Z (funcomp X Y Z f g) z)
  : hfiber Y Z g z = (f xe.1, xe.2)

constr2 (X Y : U) (f : X -> Y) (g : Y -> X) (efg: (y : Y) -> paths Y (f (g y)) y) (x0 : X) (xe : hfiber Y X g x0)
  : (xe' : hfiber X X (funcomp X Y X f g) x0) * paths (hfiber Y X g x0) xe (hfibersgftog X Y X f g x0 xe')
  = ((x0, <i> comp (<_> X) (xe.2 @ i) [(i=0) -> <k> g (eint @ k), (i=1) -> <_> x0])
    ,<i> (eint @ i, <j> fill (<_> X) (xe.2 @ j) [(j=0) -> <k> g (eint @ k), (j=1) -> <_> x0] @ i))
  where
  eint : paths Y xe.1 (f x0) = pathssec1 Y X g f efg xe.1 x0 xe.2

iscontrhfiberl1 (X Y : U) (f : X -> Y) (g : Y -> X) (efg: (y : Y) -> paths Y (f (g y)) y) (x0 : X)
    (is : iscontr (hfiber X X (funcomp X Y X f g) x0)) : iscontr (hfiber Y X g x0)
  = iscontrretract (hfiber X X (funcomp X Y X f g) x0)
                   (hfiber Y X g x0)
                   (hfibersgftog X Y X f g x0)
                   (\(xe : hfiber Y X g x0) -> (constr2 X Y f g efg x0 xe).1)
                   (\(xe : hfiber Y X g x0) -> <i> (constr2 X Y f g efg x0 xe).2 @ -i)
                   is

homothfiber1 (X Y : U) (f g : X -> Y) (h : homot X (\(_:X)->Y) f g) (y : Y) (xe : hfiber X Y f y)
  : hfiber X Y g y = (xe.1, <i> comp (<_> Y) (xe.2 @ i) [(i=0) -> h xe.1, (i=1) -> <_> y])

homothfiber2 (X Y : U) (f g : X -> Y) (h : homot X (\(_:X)->Y) f g) (y : Y) (xe : hfiber X Y g y)
  : hfiber X Y f y = (xe.1, <i> comp (<_> Y) (h xe.1 @ i) [(i=0) -> <_> f xe.1, (i=1) -> xe.2])

-- Is there a better way to prove this?
homothfiberretr (X Y : U) (f g : X -> Y) (h : homot X (\(_:X)->Y) f g) (y : Y) (xe : hfiber X Y g y)
  : paths (hfiber X Y g y) (homothfiber1 X Y f g h y (homothfiber2 X Y f g h y xe)) xe
  = hfibertriangle2 X Y g y xe1 xe (idpath X xe1.1) xed
  where
  xe1 : hfiber X Y g y
      = (xe.1, (homothfiber1 X Y f g h y (homothfiber2 X Y f g h y xe)).2)

  xedl : paths (paths Y (g xe.1) y) (homothfiber1 X Y f g h y (homothfiber2 X Y f g h y xe)).2
                                    (<i> comp (<_> Y) (h xe.1 @ i) [ (i = 0) -> h xe.1, (i = 1) -> xe.2 ])
       = <j i> comp (<_> Y) (fill (<_> Y) (h xe.1 @ i) [ (i = 0) -> <_> f xe.1, (i = 1) -> <k> xe.2 @ k /\ -j ] @ -j)
                            [ (i = 0) -> h xe.1, (i = 1) -> <k> xe.2 @ k \/ -j ]

  xedl2 : paths (paths Y (g xe.1) y) (<i> comp (<_> Y) (h xe.1 @ i) [ (i = 0) -> h xe.1, (i = 1) -> xe.2 ]) xe.2
        = paths_rect Y (g xe.1)
            (\(fxe : Y) (hxe : paths Y (g xe.1) fxe) ->
              paths (paths Y (g xe.1) y) (<i> comp (<_> Y) (hxe @ -i) [ (i = 0) -> <k> hxe @ -k, (i = 1) -> xe.2 ]) xe.2 )
            (<i> pathscomp0lid Y (g xe.1) y xe.2 @ -i) (f xe.1) (<i> h xe.1 @ -i)

  xed : paths (paths Y (g xe.1) y) (homothfiber1 X Y f g h y (homothfiber2 X Y f g h y xe)).2 xe.2
      = <i> comp (<_> paths Y (g xe.1) y) (xedl @ i) [(i=0) -> <_> xedl @ 0, (i=1) -> xedl2]

iscontrhfiberl2 (X Y : U) (f g : X -> Y) (h : homot X (\(_:X)->Y) f g) (y : Y) (is : iscontr (hfiber X Y f y))
  : iscontr (hfiber X Y g y)
  = iscontrretract (hfiber X Y f y)
                   (hfiber X Y g y)
                   (homothfiber1 X Y f g h y)
                   (homothfiber2 X Y f g h y)
                   (homothfiberretr X Y f g h y)
                   is

isweqhomot (X Y : U) (f1 f2 : X -> Y) (h : homot X (\(_:X)->Y) f1 f2) (x0 : isweq X Y f1)
  : isweq X Y f2
  = \(y : Y) -> iscontrhfiberl2 X Y f1 f2 h y (x0 y)

-- Note: this is (almost) the same as gradLemma from the prelude
gradth (X Y : U) (f : X -> Y) (g : Y -> X) (egf: (x : X) -> paths X (g (f x)) x) (efg: (y : Y) -> paths Y (f (g y)) y)
  : isweq X Y f
  = \(y : Y) -> iscontrhfiberl1 Y X g f egf y (X0 y)
  where
  efg' (y : Y) : paths Y y (f (g y)) = <i> efg y @ -i
  
  X0 (y : Y) : iscontr (hfiber Y Y (funcomp Y X Y g f) y)
             = iscontrhfiberl2 Y Y (idfun Y) (funcomp Y X Y g f) efg' y (idisweq Y y)

{-
Note for later: we can generate paths from this like so;

fiber (A B : U) (f : A -> B) (y : B) : U = (x : A) * paths B y (f x)
isContr (A : U) : U = (x : A) * ((y : A) -> paths A x y)
isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)

eQconv (A B : U) (f : A -> B) (w : isweq A B f) : isEquiv A B f
  = d where d (y : B) : isContr (fiber A B f y) = b where 
    hfc (h : hfiber A B f y) : fiber A B f y = (h.1, <i> h.2 @ -i)
    fhc (h : fiber A B f y) : hfiber A B f y = (h.1, <i> h.2 @ -i)
    b : isContr (fiber A B f y) = (hfc (w y).1, \(y0 : fiber A B f y) -> <i> hfc ((w y).2 (fhc y0) @ -i))

isoId (A B : U) (f : A -> B) (g : B -> A)
      (s : (y : B) -> paths B (f (g y)) y)
      (t : (x : A) -> paths A (g (f x)) x) : paths U A B =
       <i> glue B [ (i = 0) -> (A,f,eQconv A B f (gradth A B f g t s))
                  , (i = 1) -> (B,idfun B,eQconv B B (idfun B) (idisweq B)) ]

It *might* be a good idea to go back and redefine iscontr and hfiber to align with the above definitions. Preliminary attempts have shown this to be *very* annoying. A large refactoring effort should be done to make functions like pathssec1 consistent with the above format, if this is to be pursued.
-}

weqgradth (X Y : U) (f : X -> Y) (g : Y -> X) (egf : (x : X) -> paths X (g (f x)) x) (efg : (y : Y) -> paths Y (f (g y)) y)
  : weq X Y = (f, gradth X Y f g egf efg)


